# 数据库

## 基本概念
> * [主键、外键](#主键外键)
> * [数据库范式](#数据库范式)
> * [内连接、左右外连接](#内连接左右外连接)
> * [存储过程](#存储过程)
> * [触发器](#触发器)
> * [视图和游标](#视图和游标)

## 索引及优化
> * [聚集索引和非聚集索引](#聚集索引和非聚集索引)
> * [查询优化](#查询优化)

## 事务
> * [事务的四大特性ACID](#事务的四大特性ACID)
> * [事务的并发](#事务的并发)
> * [事务的隔离级别](#事务的隔离级别)

## 存储引擎
> * [MyISAM和InnoDB区别](#MyISAM和InnoDB区别)

## 数据库锁
> * [mysql中锁的级别](#mysql中锁的级别)
> * [乐观锁和悲观锁](#乐观锁和悲观锁)

## 主键、外键
* 主键
    * 数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（NULL）。 
* 外键
    *  在一个表中存在的另一个表的主键称此表的外键。

## 数据库范式
范式之间的关系，第一范式包含第二范式，第二范式包含第三范式。这里只举反例，因为实际的数据在设计数据库表的时候，范式都是相对的。

* **第一范式 1NF**
    * **确保每列保持原子性，所有字段值都是不可分解的原子值**
    * 比如，学生包括学号、姓名；地址包括省份，城市。若在使用中经常访问学号，城市等字段，则建表时，不能把学生、地址作为字段，若将其作为字段，则不满足第一范式。
    * 将学号、城市等作为字段，符合第一范式（相对来讲，因为城市还是可以可分的，只是平时访问的多，也不会访问城市以下的字段）
* **第二范式 2NF**
    *  **需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）；**或者说每一个非主属性都完全函数依赖与任何一个主键
    *  比如，学号，课程号，学院，成绩建一个数据库表。此时（学号，课程号）为主键，也称联合主键，此时只能当学号，课程号两者都确定的情况下，才能确定成绩。但学院只与学号有关，因此部分依赖与联合主键，这种情况不符合第二范式。
* **第三范式 3NF**
    *  **数据表中的每一列数据都和主键直接相关，而不能间接相关**；或每一个非主属性既不传递依赖主键，也不部分依赖主键。
    *  订单表【Order】（OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity）主键是（OrderID），CustomerName，CustomerAddr，CustomerCity 直接依赖的是 CustomerID（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合3NF。

## 内连接、左右外连接
* 内连接: 只连接匹配的行
* 左外连接: 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行
* 右外连接: 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行

## 存储过程

## 触发器

## 视图和游标

## 事务的四大特性ACID
### 事务
事务是用户自定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。在关系数据库中，事务可以是一条SQL语句，也可以是一组SQL语句。
### 四大特性ACID
事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。

* 原子性
    * 事务所包含的一系列数据库操作要么全部成功执行，要么全部回滚
    * 事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响
* 一致性
    *  事务必须使数据库从一个一致性状态变换到另一个一致性状态
    *  一个事务执行之前和执行之后都必须处于一致性状态。 
* 隔离性
    * 并发执行的事务之间不能相互影响
    * 当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰
* 持久性
    * 指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的
    * 即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 

### 事务的并发
从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题，然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行， 在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行，这样会带来一些问题。

* 脏读
    * 一个事务读取了另一个事务未提交的数据；
    * 事务A读取事务B更新的数据，然后事务B回滚，此时事务A读到的是脏数据
* 不可重复读
    * 不可重复读的**重点是修改**，同样条件下两次读取结果不同，也就是说，被读取的数据可以被其它事务修改；
    * 事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致
* 幻读
    * 幻读的**重点在于新增或者删除**，同样条件下两次读出来的记录数不一样。
    * 事务A统计表中的数据，此时事务B想表中添加或删除了数据，当事务A再次统计表中的数据时，发现两次的记录不一样。
* 不可重复读和幻读的区别
    * 不可重复读侧重于修改，幻读侧重于新增或删除。
    * 解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。 

### 事务的隔离级别


## MyISAM和InnoDB区别
在MySQL 5.5之前，MyISAM是mysql的默认数据库引擎，之后的版本是InnoDB

