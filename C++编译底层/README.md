# C/C++编译底层

> * [C++内存管理](#C++内存管理)
> * [LINUX进程区分段及存储数据](#LINUX进程区分段及存储数据)
> * [GCC编译流程](#GCC编译流程)
> * [动态库静态库区别及LINUX加载库](#动态库静态库区别及GCC加载库)



## C++内存管理
> * **栈** 存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长
> * **堆** malloc/free开辟内存的空间，从低地址向高地址增长
> * **自由存储区** new/delete开辟内存空间
> * **数据区** 
数据区包含全局/静态存储区和常量存储区，存储已初始化的全局变量和静态变量、未初始化的全局变量和静态变量及字符串常量
> * **代码区** 存储程序的机器代码和程序指令

## LINUX进程区分段及存储数据
Linux的每个进程都有各自独立的4G逻辑地址，其中0~3G是用户态空间，3~4G是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。
逻辑地址分段如下，自下而上：
> * 代码段。分为只读存储区和代码区，存放字符串是常量和程序机器代码和指令
> * 数据段。存储已初始化的全局变量和静态变量。
> * bss段。存储未初始化的全局变量和静态变量，及初始化为0的全局变量和静态变量
> * 堆。 当进程未调用malloc时是没有堆段的，malloc/free开辟的内存空间，向上生长
> * 映射区。存储动态链接库以及调用mmap函数进行的文件映射
> * 栈。存储函数的返回地址、参数、局部变量、返回值，向下生长。

## GCC编译流程
* 预处理阶段：hello.c -- "gcc -E预处理，头文件展开，宏替换" --> hello.i
* 编译阶段：hello.i -- "gcc -s生成汇编文件" --> hello.s
* 汇编阶段：hello.s -- "gcc -c生成二进制文件" --> hello.o
* 链接阶段：hello.o -- "调用ld进行链接" --> a.out

## 动态库静态库区别及GCC加载库
静态库
> * 编译时期链接
> * 浪费空间和资源，如果多个程序链接了同一个库，则每一个生成的可执行文件就都会有一个库的副本，必然会浪费系统空间。
> * 若静态库需修改，需重新编译所有链接该库的程序

动态库
> * 运行时链接
> * 运行时被链接，故程序的运行速度稍慢
> * 动态库是在程序运行时被链接的，所以磁盘上只须保留一份副本，因此节约了磁盘空间。如果发现了bug或要升级也很简单，只要用新的库把原来的替换掉即可

GCC编译加载静态库

* 将所有的.c文件编译成.o目标文件
    * `gcc -c add.c` 生成add.o
    * `gcc -c max.c` 生成max.o
* 对生成的.o目标文件打包生成静态库
    * `ar crv libfoo.a add.o max.o //libfoo.a是库的名字`
    * ar:做库的命令
    * c:创建库
    * r:将方法添加到库里
    * v：显示过程，可以不要
    
* 使用静态库
    * `gcc -o main main.c -static -L. -lfoo //这里写的foo是去掉前后缀后库的名字`
    * -L：指定路径 .代表当前路径
    * -l：指定库名

GCC编译加载动态库

* 对生成的.o文件处理生成共享库，共享库的名字为libfoo.so
    * `gcc -shared -fPIC -o libfoo.so add.o max.o`
    * -shared 表示输出结果是共享库类型的
    * -fPIC 表示使用地址无关代码（Position Independent Code）技术来生产输出文件

* 库的使用
    * `cp libfoo.so /usr/lib //将库拷贝到系统库路径下`（不推荐）
    * export更改LD_LIBRARY_PATH当前终端的环境变量
    * 修改/etc/ld.so.conf文件，加入库文件所在目录的路径，然后 
运行ldconfig 目录名字，该命令会重建/etc/ld.so.cache文件即可 

    * 上面三种选一个即可`gcc -o main main.c -lfoo`
    

