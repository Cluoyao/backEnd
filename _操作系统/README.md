# 操作系统


> * [并行和并发](#并行和并发)
> * [计算密集任务和IO密集任务](#计算密集任务和IO密集任务)
> * [单核CPU/多核CPU/多CPU](#单核CPU多核CPU多CPU)
> * [什么时候使用多线程和多进程](#什么时候使用多线程和多进程)
> * [进程](#进程)
> * [进程间通信](#进程间通信)
> * [进程调度算法](#进程调度算法)
> * [僵尸进程和孤儿进程](#僵尸进程和孤儿进程)
> * [进程状态转移](#进程状态转移)
> * [进程间共享和私有资源](#进程间共享和私有资源)
> * [线程](#线程)
> * [协程](#协程)
> * [线程间同步](#线程间同步)
> * [线程间共享和私有资源](#线程间共享和私有资源)
> * [进程与线程的区别](#进程与线程的区别)
> * [用户态和内核态](#用户态和内核态)
> * [什么是虚拟内存](#什么是虚拟内存)
> * [缺页中断](#缺页中断)
> * [虚拟内存置换算法](#虚拟内存置换算法)
> * [虚拟内存页表寻址](#虚拟内存页表寻址)
> * [说一下LINUX系统中的锁](#说一下LINUX系统中的锁)
> * [自旋锁发生死锁](#自旋锁发生死锁)
> * [死锁产生的条件](#死锁产生的条件)
> * [如何避免死锁](#如何避免死锁)
> * [死锁检测和死锁恢复](#死锁检测和死锁恢复)

## 并行和并发
* 并发
    * 在同一时刻只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果。

* 并行
    * 在同一时刻，有多条指令在多个处理器上同时执行。

## 计算密集任务和IO密集任务
* 计算密集型任务
    * 特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。
    * 虽然可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。

* IO密集型任务
    * 涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。
    * 对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。

## [单核CPU/多核CPU/多CPU](https://www.cnblogs.com/csfeng/p/8670704.html)

> * 都是一个CPU，不同的是每个CPU上的核心数。
> * 多核CPU是多个CPU的替代方案，同时也减少了功耗。
> * 一个核心只能同时执行一个线程。

* 单核CPU
    * 一个CPU中只有一个核心处理器
* 多核CPU
    * 一个CPU有多个核心处理器，处理器之间通过**CPU内部总线**进行通讯
* 多CPU
    * 简单的多个CPU工作在同一个系统上，多个CPU之间通过**主板上的总线**进行通讯

### 深入理解进程和线程
* 进程的调度和资源分配是操作系统负责

* 线程的调度和资源分配是CPU负责

* 进程是操作系统资源分配(包括cpu、内存、磁盘IO等)的基本单位，一个CPU同时刻只能执行一个进程
    * **单核CPU实现多进程，并发。** 通过操作系统的进程调度算法，单核CPU进行进程调度的时候，需要读取上下文+执行程序+保存上下文，即进程切换。
    * **多CPU实现多进程，并行。** 不同的进程运行在不同的CPU上。
    
* 线程是CPU调度和资源分配的基本单位，一个CPU核心同时刻只能执行一个线程
    * **单核CPU实现多线程，并发。** 不同线程为了使用CPU核心，则会进行线程切换，但是由于共享了程序执行环境，这个线程切换比进程切换开销少了很多。
    * **多核CPU实现多线程，并行。** CPU可以将不同线程分配到不同的CPU核心处理器中。

> * 单CPU中进程只能是并发，多CPU计算机中进程可以并行。
> * 单CPU单核中线程只能并发，单CPU多核中线程可以并行。
> * 并行有上限，进程与CPU个数，线程与CPU核心个数有关，并不是所有线程和所有进程都能同时运行

## 什么时候使用多进程和多线程
* 多核CPU——计算密集型任务。此时要尽量使用多线程，可以提高任务执行效率，例如加密解密，数据压缩解压缩（视频、音频、普通数据），否则只能使一个核心满载，而其他核心闲置.
* 单核CPU——计算密集型任务。此时的任务已经把CPU资源100%消耗了，就没必要也不可能使用多线程来提高计算效率了；相反，如果要做人机交互，最好还是要用多线程，避免用户没法对计算机进行操作。
* 单核CPU——IO密集型任务，使用多线程还是为了人机交互方便.
* 多核CPU——IO密集型任务，这就更不用说了，跟单核时候原因一样。

## 进程

##进程间通信
##进程调度算法
##僵尸进程和孤儿进程
##进程状态转移
##进程间共享和私有资源
##线程
##协程
##线程间同步
##线程间共享和私有资源
##进程与线程的区别
##用户态和内核态
##什么是虚拟内存
##缺页中断
##虚拟内存置换算法
##虚拟内存页表寻址
##说一下LINUX系统中的锁
##自旋锁发生死锁

## 死锁产生的条件
多个并发进程因争夺系统资源而产生相互等待的现象。

* 互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；

* 请求和保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源

* 不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放

* 环路等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链 ，环路中每个进程都在等待下一个进程所占有的资源

## 如何避免死锁
* **破坏请求和等待条件。**所有的进程在开始运行之前，必须一次性地申请其在整个运行过程中所需要的全部资源
* **破坏不可抢占条件。**当进程新的资源未得到满足时，释放已占有的资源
* **破坏环路等待条件。**系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反

## 死锁检测和死锁恢复
* 死锁检测
    * 每种类型一个资源的死锁检测
    * 每种类型多个资源的死锁检测
* 死锁恢复
    * **抢占恢复。**从一个或多个进程中抢占足够数量的资源分配给死锁进程，以解除死锁状态
    * **回滚恢复。**周期性地检查进程的状态（包括请求的资源），将其写入一个文件，当发生死锁，回滚到前面的某个时间点
    * **杀死进程恢复。**终止或撤销系统中的一个或多个死锁进程，直至打破死锁状态。

