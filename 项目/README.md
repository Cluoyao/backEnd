# 项目

## Linux下多并发web服务器
> * [简述](#简述)
> * [问题](#问题)

## 无人机图像拼接及车辆检测定位
> * [无人机简述](#无人机简述)
> * [无人机问题](#无人机问题)

## 设定场景下的车牌识别
> * [车牌简述](#车牌简述)
> * [车牌问题](#车牌问题)

## 2019华为软挑
> * [华为简述](#华为简述)
> * [华为问题](#华为问题)

## 简述
### 功能
* 这个项目是基于C/C++语言和B/S模型完成的web服务器，主要实现了web端的注册和登录、实现了同步和异步日志，记录服务器运行状态的功能。

### 框架
* 项目框架主要分为I/O处理单元、逻辑处理单元和存储单元三个模块。其中I/O处理单元和逻辑处理单元对应**半同步/半反应堆线程池**，逻辑处理单元和存储单元对**应数据库连接池和日志系统**，这里实现了同步和异步写日志，另外还实现了非活动连接的处理和压力测试。

### 模块设计
* 半同步/半反应堆连接池
    * 创建固定数量的线程
        * 构造函数中创建线程池,pthread_create函数中将类的对象(this)作为参数传递给静态函数(worker),在静态函数中引用这个对象,并调用其动态方法(run)
    * 信号量sem m_queuestat提醒是否有任务要处理
    * 向请求队列中添加任务
        * 通过list容器创建请求队列
        * 向队列中添加时,通过互斥锁保证线程安全
        * 添加完成后通过信号量提醒有任务要处理
    * 工作静态函数
        * 调用对象,使用对象的动态方法run
    * 动态方法run执行任务
        * 信号量等待
        * 被唤醒后先加互斥锁
        * 从请求队列中取出第一个任务,将任务从请求队列删除
        * process(模板类中的方法,这里是http类)进行处理

* 主从状态机
* 数据库连接池
* 注册和登录校验
    * CGI多进程
        * 在http响应的代码中，创建管道，通过fork创建子进程
        * 子进程中，关闭管道读端，将标准输出重定向到管道写端dup2，子进程通过execl执行登录注册程序，在程序中先初始化数据库连接池，然后获取连接，http的POST请求获取user和name进行注册和登录校验，返回成功或失败
        * 父进程中，关闭管道写端，打开管道读端，读取CGI的返回值，响应http的请求
    * 同步线程
        * 由于CGI多进程中使用数据库连接池非常鸡肋，将数据库连接池初始化放在主线程中，响应http的代码中从数据库连接池获取连接，执行注册和登录验证。
* 服务器日志系统
* 非活动连接处理
    * 
* 压力测试

### 以**一个请求到来具体的处理过程**来介绍项目工作流程
* web端和服务器端建立连接，采用**epoll的边缘触发模式**同时监听多个文件描述符，采用**同步I/O模拟proactor模式**处理事件，此时主线程负责监听客户端是否发起请求，当web端发起http请求时，主线程接收请求报文，然后将任务插入请求队列，由工作线程通过竞争从请求队列中获取任务，通过**http类中的主从状态机**对请求报文进行分析，根据请求报文对客户端进行http响应，然后由主线程给客户端发送响应报文。
* 单例模式创建数据库连接池，避免频繁建立连接，用于后续web端登录和注册校验访问服务器数据库
* 访问服务器端的数据库实现web端的登录和注册，web访问的欢迎界面为GET请求，登录和注册界面是POST请求。欢迎界面有新用户（0）和已有账号（1）两个选项，若选择新用户，会跳转注册(3)界面，注册成功或选择已有账号，跳转登录(2)界面，注册或登录失败会提示失败，成功和失败为0，1
* 服务器运行过程中可以通过同步和异步的方式写入日志文件，记录服务器运行状态
    * 同步的方式下，工作线程直接写入日志文件
    * 异步的话会另外创建一个写线程，工作线程将要写的内容push进请求队列，然后通过写线程写入文件
    * 另外，日志文件支持按日期分类，和超过最大行数自动创建新文件
* 非活动连接的处理。由于非活跃连接占用了连接资源，严重影响服务器的性能，通过实现一个服务器定时器，处理这种非活跃连接，释放连接资源。利用alarm函数周期性地触发SIGALRM信号,该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务.

## 问题
### reactor模式/proactor模式
* reactor模式中，主线程只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程，读写数据、接受新连接及处理客户请求均在工作线程中完成。
* proactor模式中，主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程仅负责业务逻辑，如处理客户请求

### 同步I/O模拟proactor模式
* 主线程执行数据读写操作，读写完成之后，主线程通知工作线程。从工作线程的角度来看，他们直接获得了数据读写的结果，接下来只负责逻辑处理。

### 五种I/O
> * 阻塞IO:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作
> * 非阻塞IO:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I/O执行系统调用总是立即返回，不管时间是否已经发生，若时间没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept，recv和send，事件未发生时，errno通常被设置成eagain
> * 信号驱动IO:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。
> * IO复用:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数
> * 异步IO:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。

**注意：阻塞I/O，非阻塞I/O，信号驱动I/O和I/O复用都是同步I/O。同步I/O要求用户代码自行执行I/O操作，异步I/O机制则由内核完成I/O操作**

### [select/poll/epoll](https://blog.csdn.net/u012398613/article/details/51787548)
* 调用函数
    * select和poll都是一个函数，epoll是一组函数
* 文件描述符数量
    * select通过线性表描述文件描述符集合，文件描述符有上限，一般是1024，但可以修改源码，重新编译内核，不推荐
    * poll是链表描述，突破了文件描述符上限，最大可以打开文件的数目
    * epoll通过红黑树描述，最大可以打开文件的数目，可以通过命令ulimit -n number修改，仅对当前终端有效
* 将文件描述符从用户传给内核
    * select和poll通过将所有文件描述符拷贝到内核态，每次调用都需要拷贝
    * epoll通过epoll_create建立一棵红黑树，通过epoll_ctl将要监听的文件描述符注册到红黑树上
* 内核判断就绪的文件描述符
    * select和poll通过遍历文件描述符集合，判断哪个文件描述符上有事件发生
    * epoll
        * epoll_create时，内核除了帮我们在epoll文件系统里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。
        * epoll是根据每个fd上面的回调函数(中断函数)判断，只有发生了事件的socket才会主动的去调用 callback函数，其他空闲状态socket则不会，若是就绪事件，插入list
    
* 应用程序索引就绪文件描述符
    *  select/poll只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历
    *  epoll返回的发生了事件的个数和结构体数组，结构体包含socket的信息，因此直接处理返回的数组即可
* 工作模式
    * select和poll都只能工作在相对低效的LT模式下
    * epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。   

### epoll的ET、LT、epolloneshot
* LT水平触发模式
    * epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序可以不立即处理该事件。
    * 当下一次调用epoll_wait时，epoll_wait还会再次向应用程序报告此事件，直至被处理
* ET边缘触发模式
    *  epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件
    * 必须要一次性将数据读取完，使用非阻塞I/O，读取到出现eagain
* EPOLLONESHOT
    * 一个线程读取某个socket上的数据后开始处理数据，在处理过程中该socket上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket
    * 我们期望的是一个socket连接在任一时刻都只被一个线程处理，通过epoll_ctl对该文件描述符注册epolloneshot事件，注册时候，一个线程处理socket时，其他线程将无法处理，当该线程处理完后，需要通过epoll_ctl重置

### 什么是优雅关闭连接
close()和shutdown()

### [多线程的pthread_cond_wait后，记住再次检测条件](https://tower.iteye.com/blog/309294)




