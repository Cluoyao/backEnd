# 项目

## Linux下多并发web服务器
> * [简述](#简述)
> * [问题](#问题)

## 无人机

## 设定场景下的车牌识别

## 2019华为软挑

## 简述
* 功能
    * 这个项目是基于C/C++语言和B/S模型完成的web服务器，主要实现了web端的注册和登录功能。
* 模块
    * 项目主要分为I/O处理单元、逻辑处理单元和存储单元三个模块。其中I/O处理单元和逻辑处理单元对应**半同步/半反应堆线程池**，逻辑处理单元和存储单元对**应数据库连接池和日志系统**，这里实现了同步和异步写日志，另外还实现了非活动连接的处理和压力测试。

* 以**一个请求到来具体的处理过程**来介绍项目工作流程
    * web端和服务器端建立连接，通过**epoll的I/O端口复用**技术同时监听多个文件描述符，此时主线程负责监听客户端是否发起请求，当web端发起http请求时，主线程接收请求报文，然后将任务插入请求队列，由工作线程通过竞争从请求队列中获取任务，通过**http类中的主从状态机**对请求报文进行分析，根据请求报文对客户端进行http响应，然后由主线程给客户端发送响应报文
    * 服务器运行过程中产生的输出内容可以通过同步和异步的方式写入日志文件。
        * 同步的方式下，工作线程直接写入日志文件
        * 异步的话会另外创建一个写线程，工作线程将要写的内容push进请求队列，然后通过写线程写入文件
        * 另外，日志文件支持按日期分类，和超过最大行数自动创建新文件
    * 在web端的登录和注册时，实现了两种方式，一种是CGI多进程，另一种是同步线程
    * 建立了数据库连接池，处理
    

* 半同步/半反应堆线程池
    *  使用请求队列解除了主线程和工作线程间的耦合关系，主线程负责往请求队列中插入任务，工作线程通过竞争从请求队列中获取任务，然后执行。
    *  
* 异步日志系统
    

## 问题
### reactor模式/proactor模式
* reactor模式中，主线程只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程，读写数据、接受新连接及处理客户请求均在工作线程中完成。
* proactor模式中，主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程仅负责业务逻辑，如处理客户请求

### 同步I/O模拟proactor模式
* 主线程执行数据读写操作，读写完成之后，主线程通知工作线程。从工作线程的角度来看，他们直接获得了数据读写的结果，接下来只负责逻辑处理。

### 五种I/O
> * 阻塞IO:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作
> * 非阻塞IO:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I/O执行系统调用总是立即返回，不管时间是否已经发生，若时间没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept，recv和send，事件未发生时，errno通常被设置成eagain
> * 信号驱动IO:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。
> * IO复用:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数
> * 异步IO:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。

**注意：阻塞I/O，非阻塞I/O，信号驱动I/O和I/O复用都是同步I/O。同步I/O要求用户代码自行执行I/O操作，异步I/O机制则由内核完成I/O操作**

### [select/poll/epoll](https://blog.csdn.net/u012398613/article/details/51787548)
* 调用函数
    * select和poll都是一个函数，epoll是一组函数
* 文件描述符数量
    * select通过线性表描述文件描述符集合，文件描述符有上限，一般是1024，但可以修改源码，重新编译内核，不推荐
    * poll是链表描述，突破了文件描述符上限，最大可以打开文件的数目
    * epoll通过红黑树描述，最大可以打开文件的数目，可以通过命令ulimit -n number修改，仅对当前终端有效
* 将文件描述符从用户传给内核
    * select和poll通过将所有文件描述符拷贝到内核态，每次调用都需要拷贝
    * epoll通过epoll_create建立一棵红黑树，通过epoll_ctl将要监听的文件描述符注册到红黑树上
* 内核判断就绪的文件描述符
    * select和poll通过遍历文件描述符集合，判断哪个文件描述符上有事件发生
    * epoll
        * epoll_create时，内核除了帮我们在epoll文件系统里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。
        * epoll是根据每个fd上面的回调函数(中断函数)判断，只有发生了事件的socket才会主动的去调用 callback函数，其他空闲状态socket则不会，若是就绪事件，插入list
    
* 应用程序索引就绪文件描述符
    *  select/poll只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历
    *  epoll返回的发生了事件的个数和结构体数组，结构体包含socket的信息，因此直接处理返回的数组即可
* 工作模式
    * select和poll都只能工作在相对低效的LT模式下
    * epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。   

### epoll的ET、LT、epolloneshot
* LT水平触发模式
    * epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序可以不立即处理该事件。
    * 当下一次调用epoll_wait时，epoll_wait还会再次向应用程序报告此事件，直至被处理
* ET边缘触发模式
    *  epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件
    * 必须要一次性将数据读取完，使用非阻塞I/O，读取到出现eagain
* EPOLLONESHOT
    * 一个线程读取某个socket上的数据后开始处理数据，在处理过程中该socket上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket
    * 我们期望的是一个socket连接在任一时刻都只被一个线程处理，通过epoll_ctl对该文件描述符注册epolloneshot事件，注册时候，一个线程处理socket时，其他线程将无法处理，当该线程处理完后，需要通过epoll_ctl重置

### 什么是优雅关闭连接
close()和shutdown()




