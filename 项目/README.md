# 项目

## Linux下多并发web服务器
> * [简述](#简述)
> * [问题](#问题)

## 无人机图像拼接及车辆检测定位
> * [无人机简述](#无人机简述)
> * [无人机问题](#无人机问题)

## 设定场景下的车牌识别
> * [车牌简述](#车牌简述)
> * [车牌问题](#车牌问题)

## 2019华为软挑
> * [华为简述](#华为简述)
> * [华为问题](#华为问题)

## 简述
### 功能
* 这个项目是基于C/C++语言和B/S模型完成的web服务器，主要实现了web端的注册和登录、实现了同步和异步日志，记录服务器运行状态的功能，并支持http长连接，不支持管线化请求。

### 框架
* 项目框架主要分为I/O处理单元、逻辑处理单元和存储单元三个模块。其中I/O处理单元和逻辑处理单元对应**半同步/半反应堆线程池**，逻辑处理单元和存储单元对**应数据库连接池和日志系统**，这里实现了同步和异步写日志，另外还实现了非活动连接的处理和压力测试。

### 模块设计
#### **半同步/半反应堆连接池**
* 主线程为异步线程
    * 负责监听文件描述符，接收socket新连接，操作I/O，读写客户端请求，然后将任务插入到请求队列
    * 主线程read
        * 客户端发送请求后，主线程循环读取完请求报文，存储到指定的buffer，并设置read_index指示长度
    * 主线程write
        * 当process_write写完后，注册epollout事件，此时主线程会通过判断write_index是否为空来判断是否能写 
        * 给客户端发送响应请求，判断是否发送成功，byte_to_send <= byte_have_send
        * 若发送成功，先取消mmap映射，然后判断是否是长连接，长连接重置http类实例，注册读事件，不关闭连接，否则关闭连接
        * 若发送不成功，判断是否是写缓冲区满了，若不是因为缓冲区满了而失败，取消mmap映射，关闭连接；若eagain则满了，注册写事件，等待下一次写事件触发（当写缓冲区从不可写变为可写，触发epollout），因此在此期间无法立即接收到同一用户的下一请求，但可以保证连接的完整性
        
* 请求队列
    * list链表实现，信号量sem提醒是否有任务要处理
* 工作线程
    * 创建固定数量的线程
        * 构造函数中创建线程池,pthread_create函数中将类的对象(this)作为参数传递给静态函数(worker),在静态函数中引用这个对象,并调用其动态方法(run)
        * pthread_create(m_threads+i, NULL, worker, this)
        * 设置线程分离detach，自动回收
    * 向请求队列中添加任务
        * 通过list容器创建请求队列
        * 向队列中添加时,通过互斥锁保证线程安全
        * 添加完成后通过信号量提醒有任务要处理sem.post()
    * 工作静态函数
        * 调用对象,使用对象的动态方法run
    * 动态方法run执行任务
        * 信号量等待sem.wait()
        * 被唤醒后先加互斥锁
        * 从请求队列中取出第一个任务list.front(),将任务从请求队列删除list.pop_front()
        * process(模板类中的方法,这里是http类)进行处理

#### **主从状态机**
主线程负责读取客户端的请求，放到指定buffer内，（此时存在一个读取的read_index）由工作线程对http请求进行解析，这里参考游双的高性能服务器编程设计了主从状态机，其中主状态机从内部调用从状态机。

* 主状态机，负责解析请求行和头部具体数据
    * 两个状态CHECK_STATE_REQUESTLINE(请求行)，CHECK_STATE_HEADER(头部字段)，CHECK_STATE_CONTENT(当请求头部有很多字段时，判断是否读入完整)
    * 主状态机默认状态为解析http请求行，获得请求方法，目标文件url，http版本号，若能获得完整请求行，将状态转移为CHECK_STATE_HEADER
        * 请求行查找数据中空格+\t第一次出现的位置，判断请求方法是GET还是POST
        * 解析目标文件
        * 继续在剩余数据查找空格+\t第一次出现的位置，判断http版本是否是http/1.1
    * 解析http请求的一个头部信息，支持GET和POST请求，若为GET，根据空行判断是否解析完毕，若为POST，则设置cgi标志位，在响应代码中继续处理，若m_content_length不为0，状态转移为CHECK_STATE_CONTENT
        * 解析host，connection，content-length头部字段，更新m_host，m_linger，m_content_length
        * 解析connection时，判断是否是keep-alive长连接，设置长连接标志位
    * 判断请求头部是否完整读入，指主线程是否完整读入到buffer中
        * read_index >= m_content_length + m_checked_index 
* 从状态机，负责从buffer中读取完整的行数据
    * 存在自己的check_index 
    * 三个状态LINE_OK（读取成功），LINE_OPEN（未读取到完整请求），LINE_BAD（请求存在语法错误）
    * 初始状态LINK_OK，当buffer中有数据则，从状态机开始工作
    * 从buffer中解析出一行，通过判断是否存在行结束符'\r\n'，当buffer[check] == '\r'时
        * 如果存在buffer[check+1] == '\n'，那么读取到完整行，给主状态机分析
        * 如果不存在buffer[check+1] == '\r'，返回LINE_OPEN，表示还要继续读取
        * 否则，返回LINE_BAD
* http响应请求，若得到完整正确的http请求行，执行do_request()
    * get和post请求不同的方法处理
        * get方法的目标文件即之前主从状态机解析的url
        * post方法是先根据post最后一行提取出用户名和密码，进行注册和登录校验，根据post请求的不同标志位，跳转不同的文件
    * 将网站根目录和url文件拼接，然后通过stat判断该文件是否存在，是否可读，是否是目录，然后为了提高访问速度，将普通文件映射到内存地址
* 根据do_request的返回状态，工作线程向指定buffer写入响应请求
    * 先写状态行 http/1.1 状态码 状态消息
    * 写消息报头，包含content-length，connection状态，根据请求解析出的状态决定
    * 添加空行和响应正文
    * 向指定buffer写入响应请求，更新write_idx指示buffer中的长度

#### **数据库连接池**
* 单例模式创建数据库连接池


#### **注册和登录校验**
* CGI多进程
    * 在http响应的代码中，创建管道，通过fork创建子进程
    * 子进程中，关闭管道读端，将标准输出重定向到管道写端dup2，子进程通过execl执行登录注册程序，在程序中先初始化数据库连接池，然后获取连接，根据http的POST请求获取user和name进行注册和登录校验，返回成功或失败
    * 父进程中，关闭管道写端，打开管道读端，读取CGI的返回值，响应http的请求
* 同步线程
    * 由于CGI多进程中使用数据库连接池非常鸡肋，因为在execl中创建数据库连接池，将数据库连接池初始化放在主线程中，响应http的代码中从数据库连接池获取连接，执行注册和登录验证。

#### **服务器日志系统**
**请求队列，同步、异步，超行、按天分类的设计**

* 请求队列的设计
    * stl中的队列，线程不安全，每次使用push等操作时，需要频繁加锁
    * 通过条件变量和循环数组实现线程安全的队列
    * 条件变量的使用，需要注意pthread_cond_wait前需加锁，且wait后需要再次检测资源是否可用，可以用while

* 同步
    * 同步是调用写操作时，将输出信息写入日志文件
    * 当单条日志比较大的时候，同步模式会阻塞整个处理流程，那么应用能处理的并发能力将有所下降，尤其是在峰值的时候，写日志可能成为系统的瓶颈
    * 服务崩溃或者重启服务的时候不会造成日志丢失
* 异步
    * 另外创建一个写线程，工作线程将要写的内容push进请求队列，然后通过写线程写入文件 

#### **非活动连接处理**
利用alarm函数周期性地触发SIGALRM信号,调用心跳函数，该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务.

**定时器和心跳函数的设计，这里alarm设置为5秒，连接超时为15秒：**

* 定时器（主要涉及双向链表的插入，删除操作，添加定时器的事件复杂度是O(n),删除定时器的事件复杂度是O(1)，因为直接给了定时器结点，而不是值）
    * 双向链表,创建头尾节点,头尾节点没有意义，仅仅统一方便调整
    * add_timer函数将目标定时器添加到链表中，添加时按照升序添加
        * 若当前链表中只有头尾节点，直接插入
        * 否则，将定时器按升序插入
    * adjust_timer函数当定时任务发生变化,调整对应定时器在链表中的位置，如客户端在设定时间内有数据收发,则当前时刻对该定时器重新设定时间，这里只是往后延长超时时间
        * 如果被调整的目标定时器在尾部，或定时器新的超时值仍然小于下一个定时器的超时，不用调整
        * 否则先将定时器从链表取出，重新插入链表
    * del_timer函数将超时的定时器从链表中删除
        * 常规双向链表删除结点
* 回调函数
    * 将定时任务封装成回调函数，由用户自己决定，这里是删除非活动socket上的注册事件，并关闭
* 心跳函数
    * 遍历定时器链表从头结点开始依次处理每个定时器,直到遇到尚未到期的定时器
    * 若当前时间小于定时器设定时间,跳出循环,即未找到到期的定时器
    * 若当前时间大于定时器设定时间，即找到了到期的定时器,执行回调函数,然后将它从链表中删除，然后继续遍历

**定时器的使用**

* 创建管道
* 设置信号处理函数SIGALRM（时间到了触发）和SIGTERM（kill会触发）
    * 通过struct sigaction结构体和sigaction函数注册信号捕捉函数 
    * 在结构体的回调函数中设置从管道读端写入信号的名字
* 利用I/O复用系统监听管道读端文件描述符的可读事件
* 信息值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码

#### **压力测试**
*  思想
    *  通过单纯的I/O复用方式对服务器施压，因为线程和进程的调度本身也要占用一定CPU时间
    *  如果服务器足够稳定，服务器和测试程序会不断的交换数据
* 设计
    *  循环创建num个socket，向服务器发起num个TCP连接
    *  每个连接connect成功后，通过在epoll内核事件表注册epollin、epollout，监听读写事件
    *  向服务器端写request数据GET http://localhost/index.html HTTP/1.1 \r\n Connetcion:keep-alive\r\n\r\n，必须满足http中get请求的报文格式
    *  每个连接不停的向服务器发送请求request，访问主机上的文件
    *  从服务器端读数据，直接打印在终端上，显示读到的数据和字节数，与主机交换数据

### 以一个请求到来具体的处理过程介绍项目工作流程
* web端和服务器端建立连接，采用**epoll的边缘触发模式**同时监听多个文件描述符，采用**同步I/O模拟proactor模式**处理事件，此时主线程负责监听客户端是否发起请求，当web端发起http请求时，主线程接收请求报文，然后将任务插入请求队列，由工作线程通过竞争从请求队列中获取任务，通过**http类中的主从状态机**对请求报文进行分析，根据请求报文对客户端进行http响应，然后由主线程给客户端发送响应报文。
* 单例模式创建数据库连接池，避免频繁建立连接，用于后续web端登录和注册校验访问服务器数据库
* 访问服务器端的数据库实现web端的登录和注册，web访问的欢迎界面为GET请求，登录和注册界面是POST请求。欢迎界面有新用户（0）和已有账号（1）两个选项，若选择新用户，会跳转注册(3)界面，注册成功或选择已有账号，跳转登录(2)界面，注册或登录失败会提示失败，成功和失败为0，1
* 服务器运行过程中可以通过同步和异步的方式写入日志文件，记录服务器运行状态
    * 同步的方式下，工作线程直接写入日志文件
    * 异步的话会另外创建一个写线程，工作线程将要写的内容push进请求队列，然后通过写线程写入文件
    * 另外，日志文件支持按日期分类，和超过最大行数自动创建新文件
* 非活动连接的处理。由于非活跃连接占用了连接资源，严重影响服务器的性能，通过实现一个服务器定时器，处理这种非活跃连接，释放连接资源。利用alarm函数周期性地触发SIGALRM信号,该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务.

## 问题
### reactor模式/proactor模式
* reactor模式中，主线程只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程，读写数据、接受新连接及处理客户请求均在工作线程中完成。
* proactor模式中，主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程仅负责业务逻辑，如处理客户请求

### 同步I/O模拟proactor模式
* 主线程执行数据读写操作，读写完成之后，主线程通知工作线程。从工作线程的角度来看，他们直接获得了数据读写的结果，接下来只负责逻辑处理。

### 五种I/O
> * 阻塞IO:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作
> * 非阻塞IO:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I/O执行系统调用总是立即返回，不管时间是否已经发生，若时间没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept，recv和send，事件未发生时，errno通常被设置成eagain
> * 信号驱动IO:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。
> * IO复用:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数
> * 异步IO:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。

**注意：阻塞I/O，非阻塞I/O，信号驱动I/O和I/O复用都是同步I/O。同步I/O要求用户代码自行执行I/O操作，异步I/O机制则由内核完成I/O操作**

### [select/poll/epoll](https://blog.csdn.net/u012398613/article/details/51787548)
* 调用函数
    * select和poll都是一个函数，epoll是一组函数
* 文件描述符数量
    * select通过线性表描述文件描述符集合，文件描述符有上限，一般是1024，但可以修改源码，重新编译内核，不推荐
    * poll是链表描述，突破了文件描述符上限，最大可以打开文件的数目
    * epoll通过红黑树描述，最大可以打开文件的数目，可以通过命令ulimit -n number修改，仅对当前终端有效
* 将文件描述符从用户传给内核
    * select和poll通过将所有文件描述符拷贝到内核态，每次调用都需要拷贝
    * epoll通过epoll_create建立一棵红黑树，通过epoll_ctl将要监听的文件描述符注册到红黑树上
* 内核判断就绪的文件描述符
    * select和poll通过遍历文件描述符集合，判断哪个文件描述符上有事件发生
    * epoll
        * epoll_create时，内核除了帮我们在epoll文件系统里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。
        * epoll是根据每个fd上面的回调函数(中断函数)判断，只有发生了事件的socket才会主动的去调用 callback函数，其他空闲状态socket则不会，若是就绪事件，插入list
    
* 应用程序索引就绪文件描述符
    *  select/poll只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历
    *  epoll返回的发生了事件的个数和结构体数组，结构体包含socket的信息，因此直接处理返回的数组即可
* 工作模式
    * select和poll都只能工作在相对低效的LT模式下
    * epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。   

### epoll的ET、LT、epolloneshot
* LT水平触发模式
    * epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序可以不立即处理该事件。
    * 当下一次调用epoll_wait时，epoll_wait还会再次向应用程序报告此事件，直至被处理
* ET边缘触发模式
    *  epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件
    * 必须要一次性将数据读取完，使用非阻塞I/O，读取到出现eagain
* EPOLLONESHOT
    * 一个线程读取某个socket上的数据后开始处理数据，在处理过程中该socket上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket
    * 我们期望的是一个socket连接在任一时刻都只被一个线程处理，通过epoll_ctl对该文件描述符注册epolloneshot事件，注册时候，一个线程处理socket时，其他线程将无法处理，当该线程处理完后，需要通过epoll_ctl重置

### 什么是优雅关闭连接
close()和shutdown()

### [多线程的pthread_cond_wait后，记住再次检测条件](https://tower.iteye.com/blog/309294)

### 统一事件源
信号是一种异步事件:信号处理函数和程序的主循环是两条不同的执行路线。一种典型的解决方案是：把信号的主要处理逻辑放到程序的主循环中，当信号处理函数被触发时，它只是简单地通知主循环程序接收到信号，并把信息值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码。

* 信号处理函数通常使用管道来将信号传递给主循环：
    * 信号处理函数往管道的写端写入信号值类型
    * 利用I/O复用系统监听管道读端文件描述符的可读事件
    * 主循环则从管道的读端读出该信号值的类型




