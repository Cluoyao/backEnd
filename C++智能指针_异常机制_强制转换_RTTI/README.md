# C++补充

> * [构造函数可以抛出异常吗，有什么问题？](#构造函数可以抛出异常吗有什么问题)
> * [初始化列表的异常怎么捕获？](#初始化列表的异常怎么捕获)
> * [析构函数可以抛出异常吗，有什么问题？](#析构函数可以抛出异常吗有什么问题)
> * [析构函数如何处理异常](#析构函数如何处理异常)
> * [智能指针](#智能指针)
> * [强制转换](#强制转换)
> * [RTTI](#RTTI)


## [构造函数可以抛出异常吗，有什么问题？](https://www.cnblogs.com/qinguoyi/p/10304882.html)
构造函数中应该避免抛出异常。
> * 构造函数中抛出异常后，对象的析构函数将不会被执行
> * 构造函数抛出异常时，本应该在析构函数中被delete的对象没有被delete，会导致内存泄露
> * 当对象发生部分构造时，已经构造完毕的子对象（非动态分配）将会逆序地被析构。

## 初始化列表的异常怎么捕获？
> * 初始化列表构造，当初始化列表出现异常时，程序还未进入函数体，因此函数体中的try-catch不能执行，catch也无法处理异常。可以通过函数try块解决该问题。
> * 函数try块中的try出现在表示构造函数初始值列表的冒号以及表示构造函数体的花括号之前，与这个try关联的catch既能处理构造函数体抛出的异常，也能处理成员初始化列表抛出的异常。


## 析构函数可以抛出异常吗，有什么问题？
析构函数不应该抛出异常
> * **其他正常，仅析构函数异常**。 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。
> * **其他异常，且析构函数异常**。 通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。

## 析构函数如何处理异常？
> * 若析构函数抛出异常，调用std::abort()来终止程序
> * 在析构函数中catch捕获异常并作处理，吞下异常；
> * 如果客户需要对某个操作函数运次期间抛出的异常做出反应，class应该提供普通函数执行该操作，而非在析构函数中。


