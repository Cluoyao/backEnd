# 数据库

## 基本概念
> * [主键、外键](#主键外键)
> * [数据库范式](#数据库范式)
> * [内连接、左右外连接](#内连接左右外连接)
> * [存储过程](#存储过程)
> * [触发器](#触发器)
> * [视图和游标](#视图和游标)

## 索引及优化
> * [索引](#索引)
> * [聚集索引和非聚集索引](#聚集索引和非聚集索引)
> * [查询优化](#查询优化)

## 事务
> * [事务的四大特性ACID](#事务的四大特性ACID)
> * [事务的并发](#事务的并发)
> * [事务的隔离级别](#事务的隔离级别)

## 存储引擎
> * [MyISAM和InnoDB区别](#MyISAM和InnoDB区别)

## 数据库锁
> * [mysql中锁的级别](#mysql中锁的级别)
> * [乐观锁和悲观锁](#乐观锁和悲观锁)

## 主键、外键
* 主键
    * 数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（NULL）。 
* 外键
    *  在一个表中存在的另一个表的主键称此表的外键。

## 数据库范式
范式之间的关系，第一范式包含第二范式，第二范式包含第三范式。这里只举反例，因为实际的数据在设计数据库表的时候，范式都是相对的。

* **第一范式 1NF**
    * **确保每列保持原子性，所有字段值都是不可分解的原子值**
    * 比如，学生包括学号、姓名；地址包括省份，城市。若在使用中经常访问学号，城市等字段，则建表时，不能把学生、地址作为字段，若将其作为字段，则不满足第一范式。
    * 将学号、城市等作为字段，符合第一范式（相对来讲，因为城市还是可以可分的，只是平时访问的多，也不会访问城市以下的字段）
* **第二范式 2NF**
    *  **需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）；**或者说每一个非主属性都完全函数依赖与任何一个主键
    *  比如，学号，课程号，学院，成绩建一个数据库表。此时（学号，课程号）为主键，也称联合主键，此时只能当学号，课程号两者都确定的情况下，才能确定成绩。但学院只与学号有关，因此部分依赖与联合主键，这种情况不符合第二范式。
* **第三范式 3NF**
    *  **数据表中的每一列数据都和主键直接相关，而不能间接相关；**或每一个非主属性既不传递依赖主键，也不部分依赖主键。
    *  订单表【Order】（OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity）主键是（OrderID），CustomerName，CustomerAddr，CustomerCity 直接依赖的是 CustomerID（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合3NF。

## 内连接、左右外连接
* 内连接: 只连接匹配的行
* 左外连接: 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行
* 右外连接: 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行

## 存储过程
存储过程是是事先经过编译，并存储在数据库中的一段SQL语句的集合。
通俗讲，存储过程是由一些SQL语句组成的代码块，这些SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查）。

### 优点
* 存储过程只在创建时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL语句每执行一次就编译一次，所以使用存储过程可提高数据库执行效率；
* 当SQL语句有变动时，可以只修改数据库中的存储过程而不必修改代码；
* 通过存储过程能够使**没有权限的用户在控制之下**间接地存取数据库，从而确保数据的安全。


## 触发器
触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。如，某表上的触发器上包含对另一个表的数据操作，售出一件商品，仓库库存-1

## 视图和游标
* 视图
    * 一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。
* 游标
    * 对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。

## 索引
### 概念
索引是对数据库表中一列或多列值进行排序的数据结构，可以协助数据快速查询和更新数据。
### 数据结构
B/B+树，hash索引，存储引擎MyISAM和InnoDB使用的B/B+树，MEMORY/Heap有hash和B/B+，默认是hash

*  B/B+树，hash索引的区别
    * hash适用于等值查找的情况，不能进行范围查找；hash索引在任何时候都不能避免表扫描
    * hash当有大量重复键值的情况，由于hash冲突，性能并不一定就会比B-Tree索引高

* 为什么B+树比B树更适合文件系统索引
    * B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低
    * B+树的非叶子结点中只存放关键字的信息，没有存放关键字具体信息，因此结点更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了； 
    * 由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当

### 什么样的字段适合创建索引
* 经常作查询选择的字段
* 经常作表连接的字段
* 经常出现在order by, group by, distinct 后面排序或分组的字段

### 索引的缺点
* 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；
* 空间方面：索引需要占物理空间。

### 最左前缀原则

* 在创建联合索引的时候，需要做联合索引多个字段之间顺序你们是如何选择的
    * 把最频繁，识别度最高的放在最前面，因为最左前缀原则 
* 最左前缀原则：顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。


## 聚集索引和非聚集索引
聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。聚集索引的逻辑顺序和物理顺序相同，非聚集索引则不同。

### B+树叶子结点可以存哪些数据
* 聚集索引的叶节点就是数据节点，而非聚集索引的叶节点仍然是索引节点，只不过其包含一个指向对应数据块的指针
* 叶子结点存储的是主键整行数据的是聚簇索引，叶子结点存储的仅仅是主键，然后通过指针指向具体信息的是非聚簇索引。


## 查询优化


## 事务的四大特性ACID
### 事务
事务是用户自定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。在关系数据库中，事务可以是一条SQL语句，也可以是一组SQL语句。
### 四大特性ACID
事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。

* 原子性
    * 事务所包含的一系列数据库操作要么全部成功执行，要么全部回滚
    * 事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响
* 一致性
    *  事务必须使数据库从一个一致性状态变换到另一个一致性状态
    *  一个事务执行之前和执行之后都必须处于一致性状态。 
* 隔离性
    * 并发执行的事务之间不能相互影响
    * 当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰
* 持久性
    * 指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的
    * 即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 

## 事务的并发
从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题，然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行， 在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行，这样会带来一些问题。

* 脏读
    * 一个事务读取了另一个事务未提交的数据；
    * 事务A读取事务B更新的数据，然后事务B回滚，此时事务A读到的是脏数据
* 不可重复读
    * 不可重复读的**重点是修改**，同样条件下两次读取结果不同，也就是说，被读取的数据可以被其它事务修改；
    * 事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致
* 幻读
    * 幻读的**重点在于新增或者删除**，同样条件下两次读出来的记录数不一样。
    * 事务A统计表中的数据，此时事务B想表中添加或删除了数据，当事务A再次统计表中的数据时，发现两次的记录不一样。
* 不可重复读和幻读的区别
    * 不可重复读侧重于修改，幻读侧重于新增或删除。
    * 解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。 

## 事务的隔离级别
* 读未提交。最低的隔离级别，会产生脏读，不可重复读，幻读问题
* 不可重复读。会产生不可重复读，幻读问题
* 可重复读。会产生幻读问题
* 串行化。最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样

### Mysql中默认的事物隔离级别
MySQL中默认事务隔离级别是“可重复读”时并不会锁住读取到的行

* 事务隔离级别：未提交读时，写数据只会锁住相应的行。
* 事务隔离级别为：可重复读时，写数据会锁住整张表。
* 事务隔离级别为：串行化时，读写数据都会锁住整张表。

注意：优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用**悲观锁或乐观锁**来控制

## MyISAM和InnoDB区别
在MySQL 5.5之前，MyISAM是mysql的默认数据库引擎，之后的版本是InnoDB。
### InnoDB
* 支持事务
* 有行级锁定和外键约束
* 不支持FULLTEXT类型的索引
* 没有保存表的行数
* 叶子结点是聚集索引

### MyISAM
* 不支持事务
* 不支持行锁和外键，因此当INSERT或UPDATE数据时即写操作需要锁定整个表，效率便会低一些
* 叶子结点是非聚集索引

### 区别
* 事务
    * InnoDB支持，MyISAM不支持
* 行数
    * InnoDB没有保存表的行数，MyISAM保存了表的行数，可以直接读取
* 索引存储
    * InnoDB是聚集索引，MyISAM是非聚集索引
* 外键
    * InnoDB支持，MyISAM不支持 
* 锁
    * InnoDB支持行锁，表锁。行锁可以提高多用户并发操作，但InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的
    * MyISAM支持表锁

## mysql中的锁

## 乐观锁和悲观锁
### 悲观锁
先获取锁，再进行业务操作，悲观的认为所有的操作均会导致并发安全问题，因此要先确保获取锁成功再进行业务操作。
### 乐观锁
先进行业务操作，再获取锁。
### 使用场景
一般情况下，**读多写少更适合用乐观锁，读少写多更适合用悲观锁**。乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能。

